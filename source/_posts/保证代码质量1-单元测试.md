---
title: '保证代码质量1:单元测试'
date: 2020-06-04 17:20:43
categories:
  - 编程思想
tags:
  - 重构
  - 单元测试
date: 2020-06-04 21:18:35
---

### 为什么要写？

#### 帮助我们发现代码中的bug

程序运行的 bug 往往出现在一些边界条件、异常情况下，比如数组或对象未判空、网络连接超时、脏数据未兼容等。而大部分异常情况都很难在集成测试中模拟，而单元测试等粒度更细，我们可以通过穷举各种异常情况+mock的方式来模拟我们需要返回的异常，来测试代码在这些异常情况的表现。

实际上，写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。

#### 是一次自我code review

可测试性也是评判代码质量的一个重要标准。一段代码如果很难为其编写单元测试，又或者编写的单元测试不能有效的覆盖各种正常及异常情况，那往往意味着代码的设计不够合理，或是代码高度耦合，又或是违反单一职责原则或依赖倒转原则。

#### 是集成测试的有力补充

一个复杂的功能往往牵扯到很多的个模块，有些模块输出并不会展现在输出参数上，测试人员往往很难发现其中的异常情况。另一方面每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，测试人员往往很难穷举出所以测试场景。

尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层 bug 少了，那组装起来的整个系统，出问题的概率也就相应减少了。

#### 阅读单元测试能帮助你快速熟悉代码

阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。

### 影响你写单元测试的因素。

#### 为决行为

所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。下面是给出的具体示例：

```java
public class Demo{
  
  private SyncLogMapper syncLogMapper;
  /**
   *
   * 同步数据 成功返回1 失败返回-1 忽略返回0
   */
  public int syncData(){
    SyncLog log = syncLogMapper.getLastSyncLog();
    
    long currentTimestamp = System.currentTimeMillis(); 
    //同步时间间隔不足 10分钟忽略同步请求
    if (currentTimestamp < log.getSyncTime() + 600000L) { 
      return 0; 
    }
    //省略同步数据实现
  }
}
```

#### 全局变量

全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量也让编写单元测试变得困难。我举个例子来解释一下。

```java
public class WeightLimiter {
  private static AtomicInteger totalWeight = new AtomicInteger(0);
  public static final int MAX_LIMIT = 500;
  
  public boolean add(int weight){
    int currentWeight = totalWeight.addAndGet(weight);
    return currentWeight <= MAX_LIMIT;
  }
}
```

```java
public class WeightLimiterTest {
  
  public void testAdd_batchAddLessThan500(){
    WeightLimiter limiter = new WeightLimiter();
    assertTrue(limiter.add(201));
    assertTrue(limiter.add(203));
  }
  
  public void testAdd_lessThan500(){
    WeightLimiter limiter = new WeightLimiter();
    assertTrue(limiter.add(301));
  }
  
  //省略其他测试用例
}
```



上面的测试用例可能会运行失败。假设单元测试框架顺序依次执行 testAdd_lessThan500() 和 testAdd_batchAddLessThan500() 两个测试用例。在第一个测试用例执行完成之后，totalWeight 的值变成了 404；再执行第二个测试用例的时候，totalWeight 变成了 705，move() 函数返回 false，assertTrue 语句判定失败。所以，第二个测试用例运行失败。

当然，如果 WeightLimiter 类有暴露重设（reset）totalWeight 值的函数，我们可以在每次执行单元测试用例之前，把 totalWeight 重设为 0，这样就能解决刚刚的问题。

不过，每个单元测试框架执行单元测试用例的方式可能是不同的。有的是顺序执行，有的是并发执行。对于并发执行的情况，即便我们每次都把 totalWeight 重设为 0，也并不奏效。

#### 静态方法

前面我们也提到，静态方法跟全局变量一样，也是一种面向过程的编程思维。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难 mock。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中 mock 这个静态方法。除此之外，如果只是类似 Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 mock。

#### 复杂继承

相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。如果父类需要 mock 某个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候，都要 mock 这个依赖对象。对于层次很深（在继承关系类图中表现为纵向深度）、结构复杂（在继承关系类图中表现为横向广度）的继承关系，越底层的子类要 mock 的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个 mock 很多依赖对象，而且还需要查看父类代码，去了解该如何 mock 这些依赖对象。

#### 高耦合代码

如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。

### 怎么写？

#### 关注点

单元测试应该针对函数实现了什么功能来设计，而不应该针对函数的实现逻辑来设计。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了我们写单元测试的初衷。

#### 测试手段

**1、通过mock解除对外部的依赖**

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper userMapper;

   /**
     * 创建用户
     * @param context 创建用户上下文
     * @throws UserExistException 用户已存在异常，手机号注册时抛出。
     * @return 用户ID
     */
    @Override
    public Long createUser(CreateUserContext context) throws UserExistException {
        UserEntity exist = userMapper.getByMobile(context.getMobile());
        if(exist != null){
            throw new UserExistException(String.format("手机号：[%s]已注册", context.getMobile()));
        }
        UserEntity newUser = context.createUser();
        userMapper.insert(newUser);
        return newUser.getId();
    }
}
```

在createUser方法中，如果手机号已注册就会抛出UserExistException异常，手机是否注册依赖于UserMapper的查询结果，然而测试数据库不是你一个人在用，里面的数据总是在变更，这使得我们的测试结果变得不可预测。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。

```java
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = MyTestApplication.class)
public class UserServiceImplTest {

    @Mock
    private UserMapper userMapper;

    @InjectMocks
    private UserServiceImpl userService;

    @Rule
    public ExpectedException thrown= ExpectedException.none();

    @Test
    public void createUser_exist() {
        //不管getByMobile传什么参数都返回 new UserEntity()
        Mockito.doReturn(new UserEntity()).when(userMapper).getByMobile(Mockito.anyString());
        //预期会抛出UserExistException异常
        thrown.expect(UserExistException.class);
        userService.createUser(new CreateUserContext("15925607245","Mon","123456789"));
    }

    @Test
    public void createUser_notExist() {
        //不管getByMobile传什么参数都返回 null
        Mockito.doReturn(null).when(userMapper).getByMobile(Mockito.anyString());
        Long id = userService.createUser(new CreateUserContext("15925607245", "Mon", "123456789"));
        assertNotNull(id);
    }
}
```

在上面的测试用例中我们为createUser设计了2个测试用例：

+ createUser_exist() 创建的用户已存在。
+ createUser_notExist() 创建的用户不存在。

通过Mock UserMapper为getByMobile模拟输出我们想要的数据，这样我们的测试用例的测试结果总是一致的。

**2、通过依赖注入将对象间的依赖关系交由上层处理**

```java
@Service
public class RegisterServiceImpl  implements RegisterService{

    @Autowired
    private UserService userService;

    private static final String REGISTER_CODE_KEY_PREFIX = "register_code_key_";

    /**
     * 注册
     * @param context 注册上下文
     * @throws ParameterException 验证码错误时抛出              
     * @return 用户信息
     */
    @Override
    public UserDTO register(RegisterContext context) throws ParameterException{
        RedisClient redisClient = new RedisClient();
        String code = redisClient.get(REGISTER_CODE_KEY_PREFIX + context.getMobile());
        if(!context.getCode().equalsIgnoreCase(code)){
            throw new ParameterException("验证码错误");
        }
        Long id = userService.createUser(context.getCreateUserContext());
        return convert(id,context);
    }

    private UserDTO convert(Long id,RegisterContext context){
        //省略部分代码
    }
}
```

在register方法中，创建用户前需要校验用户的验证码是否正确，验证码存在redis中。然而redisClient是new出来的，这使得我们无法mock RedisClient输出我们想要的数据。我们可以应用依赖注入，将 RedisClient 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 RegisterServiceImpl 类中。重构之后的 RegisterServiceImpl 类的代码如下所示：

```java
@Service
public class RegisterServiceImpl  implements RegisterService{

    @Autowired
    private UserService userService;
    
    //将RedisClient的生命周期交由Spring管理然后使用 @Autowired 注入也可以。
    @Setter
    private RedisClient redisClient;

    private static final String REGISTER_CODE_KEY_PREFIX = "register_code_key_";

    /**
     * 注册
     * @param context 注册上下文
     * @throws ParameterException 验证码错误时抛出
     * @return 用户信息
     */
    @Override
    public UserDTO register(RegisterContext context) throws ParameterException{
        String code = redisClient.get(REGISTER_CODE_KEY_PREFIX + context.getMobile());
        if(!context.getCode().equalsIgnoreCase(code)){
            throw new ParameterException("验证码错误");
        }
        Long id = userService.createUser(context.getCreateUserContext());
        return convert(id,context);
    }

    private UserDTO convert(Long id,RegisterContext context){
        //省略部分代码
    }
}
```

现在，我们就可以在单元测试中，非常容易地将 mock  RedisClient了。重构之后的代码对应的单元测试如下所示：

```java
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = MyTestApplication.class)
public class RegisterServiceImplTest {

    @Mock
    private UserService userService;

    @Mock
    private RedisClient redisClient;

    @InjectMocks
    private RegisterService registerService;

    @Rule
    public ExpectedException thrown= ExpectedException.none();

    @Test
    public void register_codeNotExist() {
        Mockito.doReturn(null).when(redisClient).get(Mockito.anyString());
        thrown.expect(ParameterException.class);
        registerService.register(new RegisterContext("4263", "15925067235", "Mon", "123457"));
    }

    @Test
    public void register_codeWrong() {
        //省略部分代码
    }

    @Test
    public void register_codeCorrect() {
        //省略部分代码
    }

    @Test
    public void register_userNotExist() {
        //省略部分代码
    }

    @Test
    public void register_userExist() {
        //省略部分代码
    }
}
```

**3、无法通过mock或依赖注入来控住输入的话，可以通过封装来使其可mock**

考虑到并发情况下UserService.createUser(CreateUserContext context);还是存在相同手机号都注册成功的情况，所以对代码进行了如下改造

```java
public Long createUser(CreateUserContext context) throws UserExistException {
    boolean locked = false;
    try{
        locked = RedisDistributedLock.getInstance().lock(context.getMobile());
        if(!locked){
            //锁定未成功，返回null 稍后再试
            return null;
        }
        UserEntity exist = userMapper.getByMobile(context.getMobile());
        if(exist != null){
            throw new UserExistException(String.format("手机号：[%s]已注册", context.getMobile()));
        }
        UserEntity newUser = context.createUser();
        userMapper.insert(newUser);
        return newUser.getId();
    }finally {
        if (locked) {
            RedisDistributedLock.getInstance().unlock(context.getMobile());
        }
    }
}
```

通过加redis锁的方式来保证并非情况下相同的手机号不会被注册。但是RedisDistributedLock 是一个单例类。单例相当于一个全局变量，我们无法 mock（无法继承和重写方法），也无法通过依赖注入的方式来替换。如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，使它可以mock。但如果 RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？我们可以对 createUser 上锁这部分逻辑重新封装一下。具体代码实现如下所示：

```java
public class UserMobileLock {

    public boolean lock(String mobile) { 
        return RedisDistributedLock.getInstance().lock(mobile); 
    } 
    
    public void unlock(String mobile) { 
        RedisDistributedLock.getInstance().unlock(mobile); 
    }
}
```

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper userMapper;

    @Setter
    private UserMobileLock userMobileLock;
    /**
     * 创建用户
     * @param context 创建用户上下文
     * @throws UserExistException 用户已存在异常，手机号注册时抛出。
     * @return 用户ID
     */
    @Override
    public Long createUser(CreateUserContext context) throws UserExistException {
        boolean locked = false;
        try{
            locked = userMobileLock.lock(context.getMobile());
            if(!locked){
                //锁定未成功，返回null 稍后再试
                return null;
            }
            UserEntity exist = userMapper.getByMobile(context.getMobile());
            if(exist != null){
                throw new UserExistException(String.format("手机号：[%s]已注册", context.getMobile()));
            }
            UserEntity newUser = context.createUser();
            userMapper.insert(newUser);
            return newUser.getId();
        }finally {
            if (locked) {
                userMobileLock.unlock(context.getMobile());
            }
        }
    }

    @Override
    public void updatePassword(Long userId, String orlPassword, String newPassword) {

    }
}
```

针对重构过的代码，我们的单元测试代码修改为下面这个样子。这样，我们就能在单元测试代码中隔离真正的 RedisDistributedLock 分布式锁这部分逻辑了。

```java
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = MyTestApplication.class)
public class UserServiceImplTest {

    @Mock
    private UserMapper userMapper;
    
    @Mock
    private UserMobileLock userMobileLock;

    @InjectMocks
    private UserServiceImpl userService;

    @Rule
    public ExpectedException thrown= ExpectedException.none();

    @Test
    public void createUser_getLockFailed() {
        Mockito.doReturn(false).when(userMobileLock).lock(Mockito.anyString());
        Long id = userService.createUser(new CreateUserContext("15925607245", "Mon", "123456789"));
        assertNull(id);
    }
  //省略部分测试用例
}
```

**4、封装未决行为逻辑，使其变的可控制**

上面我们已经解释过，并举了个未决行为的例子，针对上面的例子我们可以封装使其变的可控制，下面是封装后的代码：

```java
public class Demo{
  
  private SyncLogMapper syncLogMapper;
  /**
   *
   * 同步数据 成功返回1 失败返回-1 忽略返回0
   */
  public int syncData(){
    SyncLog log = syncLogMapper.getLastSyncLog();
     
    //同步时间间隔不足 10分钟忽略同步请求
    if (isTooOftenlog.getSyncTime())) { 
      return 0; 
    }
    //省略同步数据实现
  }
  
  @VisibleForTesting
  protected boolean isTooOften(Long syncTime){
    long currentTimestamp = System.currentTimeMillis(); 
    return currentTimestamp < syncTime + 600000L;
  }
}
```

测试代码可以这么写：

```java
public class DemoTest{
  
  @Autowired
  private Demo demo;
  @Mock
  private SyncLogMapper syncLogMapper;
  
  private Demo mockDemo;
  @Before
  public void setUp() throws Exception {
    mockDemo = Mockito.spy(demo);
    mockDemo.setSyncLogMapper(syncLogMapper)
  }
  
  public void syncData_intervalMoreThan10Minute(){
    Mockito.doReturn(false).when(mockDemo).isTooOften(Mockito.anyLong());
    Mockito.doReturn(new SyncLog()).when(syncLogMapper).getLastSyncLog();
    int status = mockDemo.syncData();
    assertEquals(1,status);
  }
  //省略其他测试用例
}
```



#### 测试代码质量

单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。所以，相对于被测代码，我们对单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。

#### 覆盖率

实际上我们不必过于追求高覆盖率，过度关注单元测试的覆盖率会导致开发人员为了提高覆盖率，写很多没有必要的测试代码，比如 get、set 方法非常简单，没有必要测试。

### 总结

本文主要是介绍了单元测试中开发过程中所发挥的作用和各种影响编写单元测试的因素，通过这些因素也能反向发现我们代码设计上的一些缺陷。最后通过一些实际案例来讲解具体的代码测试手段。

###  参考

[《设计模式之美》](https://time.geekbang.org/column/intro/250)

